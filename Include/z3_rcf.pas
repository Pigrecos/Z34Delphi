unit z3_rcf;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }


interface

uses z3;

(**
       \brief Delete a RCF numeral created using the RCF API.

       def_API('Z3_rcf_del', VOID, (_in(CONTEXT), _in(RCF_NUM)))
 *)
procedure Z3_rcf_del(c: Z3_context; a: Z3_rcf_num); cdecl;
  external z3_dll name  'Z3_rcf_del';

(**
       \brief Return a RCF rational using the given string.

       def_API('Z3_rcf_mk_rational', RCF_NUM, (_in(CONTEXT), _in(STRING)))
 *)
function Z3_rcf_mk_rational(c: Z3_context; val: Z3_string): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_mk_rational';

(**
       \brief Return a RCF small integer.

       def_API('Z3_rcf_mk_small_int', RCF_NUM, (_in(CONTEXT), _in(INT)))
 *)
function Z3_rcf_mk_small_int(c: Z3_context; val: Integer): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_mk_small_int';

(**
       \brief Return Pi

       def_API('Z3_rcf_mk_pi', RCF_NUM, (_in(CONTEXT),))
 *)
function Z3_rcf_mk_pi(c: Z3_context): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_mk_pi';

(**
       \brief Return e (Euler's constant)

       def_API('Z3_rcf_mk_e', RCF_NUM, (_in(CONTEXT),))
 *)
function Z3_rcf_mk_e(c: Z3_context): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_mk_e';

(**
       \brief Return a new infinitesimal that is smaller than all elements in the Z3 field.

       def_API('Z3_rcf_mk_infinitesimal', RCF_NUM, (_in(CONTEXT),))
 *)
function Z3_rcf_mk_infinitesimal(c: Z3_context): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_mk_infinitesimal';

(**
       \brief Store in roots the roots of the polynomial \ccode{a[n-1]*x^{n-1} + ... + a[0]}.
       The output vector \c roots must have size \c n.
       It returns the number of roots of the polynomial.

       \pre The input polynomial is not the zero polynomial.

       def_API('Z3_rcf_mk_roots', UINT, (_in(CONTEXT), _in(UINT), _in_array(1, RCF_NUM), _out_array(1, RCF_NUM)))
 *)
function Z3_rcf_mk_roots(c: Z3_context; n: Cardinal; a: PZ3_rcf_num; roots: PZ3_rcf_num): Cardinal; cdecl;
  external z3_dll name  'Z3_rcf_mk_roots';

(**
       \brief Return the value \ccode{a + b}.

       def_API('Z3_rcf_add', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_add(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_add';

(**
       \brief Return the value \ccode{a - b}.

       def_API('Z3_rcf_sub', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_sub(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_sub';

(**
       \brief Return the value \ccode{a * b}.

       def_API('Z3_rcf_mul', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_mul(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_mul';

(**
       \brief Return the value \ccode{a / b}.

       def_API('Z3_rcf_div', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_div(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_div';

(**
       \brief Return the value \ccode{-a}.

       def_API('Z3_rcf_neg', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
 *)
function Z3_rcf_neg(c: Z3_context; a: Z3_rcf_num): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_neg';

(**
       \brief Return the value \ccode{1/a}.

       def_API('Z3_rcf_inv', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM)))
 *)
function Z3_rcf_inv(c: Z3_context; a: Z3_rcf_num): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_inv';

(**
       \brief Return the value \ccode{a^k}.

       def_API('Z3_rcf_power', RCF_NUM, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
 *)
function Z3_rcf_power(c: Z3_context; a: Z3_rcf_num; k: Cardinal): Z3_rcf_num; cdecl;
  external z3_dll name  'Z3_rcf_power';

(**
       \brief Return \c true if \ccode{a < b}.

       def_API('Z3_rcf_lt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_lt(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Boolean; cdecl;
  external z3_dll name  'Z3_rcf_lt';

(**
       \brief Return \c true if \ccode{a > b}.

       def_API('Z3_rcf_gt', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_gt(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Boolean; cdecl;
  external z3_dll name  'Z3_rcf_gt';

(**
       \brief Return \c true if \ccode{a <= b}.

       def_API('Z3_rcf_le', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_le(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Boolean; cdecl;
  external z3_dll name  'Z3_rcf_le';

(**
       \brief Return \c true if \ccode{a >= b}.

       def_API('Z3_rcf_ge', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_ge(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Boolean; cdecl;
  external z3_dll name  'Z3_rcf_ge';

(**
       \brief Return \c true if \ccode{a == b}.

       def_API('Z3_rcf_eq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_eq(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Boolean; cdecl;
  external z3_dll name  'Z3_rcf_eq';

(**
       \brief Return \c true if \ccode{a != b}.

       def_API('Z3_rcf_neq', BOOL, (_in(CONTEXT), _in(RCF_NUM), _in(RCF_NUM)))
 *)
function Z3_rcf_neq(c: Z3_context; a: Z3_rcf_num; b: Z3_rcf_num): Boolean; cdecl;
  external z3_dll name  'Z3_rcf_neq';

(**
       \brief Convert the RCF numeral into a string.

       def_API('Z3_rcf_num_to_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(BOOL), _in(BOOL)))
 *)
function Z3_rcf_num_to_string(c: Z3_context; a: Z3_rcf_num; compact: Boolean; html: Boolean): Z3_string; cdecl;
  external z3_dll name  'Z3_rcf_num_to_string';

(**
       \brief Convert the RCF numeral into a string in decimal notation.

       def_API('Z3_rcf_num_to_decimal_string', STRING, (_in(CONTEXT), _in(RCF_NUM), _in(UINT)))
 *)
function Z3_rcf_num_to_decimal_string(c: Z3_context; a: Z3_rcf_num; prec: Cardinal): Z3_string; cdecl;
  external z3_dll name  'Z3_rcf_num_to_decimal_string';

(**
       \brief Extract the "numerator" and "denominator" of the given RCF numeral.
       We have that \ccode{a = n/d}, moreover \c n and \c d are not represented using rational functions.

       def_API('Z3_rcf_get_numerator_denominator', VOID, (_in(CONTEXT), _in(RCF_NUM), _out(RCF_NUM), _out(RCF_NUM)))
 *)
procedure Z3_rcf_get_numerator_denominator(c: Z3_context; a: Z3_rcf_num; n: PZ3_rcf_num; d: PZ3_rcf_num); cdecl;
  external z3_dll name  'Z3_rcf_get_numerator_denominator';

implementation

end.