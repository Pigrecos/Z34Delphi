unit z3__fixedpoint;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

interface

uses z3;

type
  (** \brief The following utilities allows adding user-defined domains. *)
  Z3_fixedpoint_reduce_assign_callback_fptr = procedure(p1: Pointer; p2: Z3_func_decl; p3: Cardinal; p4: PZ3_ast; p5: Cardinal; p6: PZ3_ast); cdecl;
  Z3_fixedpoint_reduce_app_callback_fptr    = procedure(p1: Pointer; p2: Z3_func_decl; p3: Cardinal; p4: PZ3_ast; p5: PZ3_ast); cdecl;

  Z3_fixedpoint_new_lemma_eh   = procedure(state: Pointer; lemma: Z3_ast; level: Cardinal); cdecl;
  Z3_fixedpoint_predecessor_eh = procedure(state: Pointer); cdecl;
  Z3_fixedpoint_unfold_eh      = procedure(state: Pointer); cdecl;

(**
       \brief Create a new fixedpoint context.

       \remark User must use #Z3_fixedpoint_inc_ref and #Z3_fixedpoint_dec_ref to manage fixedpoint objects.
       Even if the context was created using #Z3_mk_context instead of #Z3_mk_context_rc.

       def_API('Z3_mk_fixedpoint', FIXEDPOINT, (_in(CONTEXT), ))
 *)
function Z3_mk_fixedpoint(c: Z3_context): Z3_fixedpoint; cdecl;
  external z3_dll name  'Z3_mk_fixedpoint';

(**
       \brief Increment the reference counter of the given fixedpoint context

       def_API('Z3_fixedpoint_inc_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
procedure Z3_fixedpoint_inc_ref(c: Z3_context; d: Z3_fixedpoint); cdecl;
  external z3_dll name  'Z3_fixedpoint_inc_ref';

(**
       \brief Decrement the reference counter of the given fixedpoint context.

       def_API('Z3_fixedpoint_dec_ref', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
procedure Z3_fixedpoint_dec_ref(c: Z3_context; d: Z3_fixedpoint); cdecl;
  external z3_dll name  'Z3_fixedpoint_dec_ref';

(**
       \brief Add a universal Horn clause as a named rule.
       The \c horn_rule should be of the form:

       \code
           horn_rule ::= (forall (bound-vars) horn_rule)
                      |  (=> atoms horn_rule)
                      |  atom
       \endcode

       def_API('Z3_fixedpoint_add_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
 *)
procedure Z3_fixedpoint_add_rule(c: Z3_context; d: Z3_fixedpoint; rule: Z3_ast; name: Z3_symbol); cdecl;
  external z3_dll name  'Z3_fixedpoint_add_rule';

(**
       \brief Add a Database fact.

       \param c - context
       \param d - fixed point context
       \param r - relation signature for the row.
       \param num_args - number of columns for the given row.
       \param args - array of the row elements.

       The number of arguments \c num_args should be equal to the number
       of sorts in the domain of \c r. Each sort in the domain should be an integral
      (bit-vector, Boolean or or finite domain sort).

       The call has the same effect as adding a rule where \c r is applied to the arguments.

       def_API('Z3_fixedpoint_add_fact', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, UINT)))
 *)
procedure Z3_fixedpoint_add_fact(c: Z3_context; d: Z3_fixedpoint; r: Z3_func_decl; num_args: Cardinal; args: PCardinal); cdecl;
  external z3_dll name  'Z3_fixedpoint_add_fact';

(**
       \brief Assert a constraint to the fixedpoint context.

       The constraints are used as background axioms when the fixedpoint engine uses the PDR mode.
       They are ignored for standard Datalog mode.

       def_API('Z3_fixedpoint_assert', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
 *)
procedure Z3_fixedpoint_assert(c: Z3_context; d: Z3_fixedpoint; axiom: Z3_ast); cdecl;
  external z3_dll name  'Z3_fixedpoint_assert';

(**
        \brief Pose a query against the asserted rules.

        \code
           query ::= (exists (bound-vars) query)
                 |  literals
        \endcode

        query returns
        - \c Z3_L_FALSE if the query is unsatisfiable.
        - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
        - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.

        def_API('Z3_fixedpoint_query', INT, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST)))
 *)
function Z3_fixedpoint_query(c: Z3_context; d: Z3_fixedpoint; query: Z3_ast): Z3_lbool; cdecl;
  external z3_dll name  'Z3_fixedpoint_query';

(**
        \brief Pose multiple queries against the asserted rules.

        The queries are encoded as relations (function declarations).

        query returns
        - \c Z3_L_FALSE if the query is unsatisfiable.
        - \c Z3_L_TRUE if the query is satisfiable. Obtain the answer by calling #Z3_fixedpoint_get_answer.
        - \c Z3_L_UNDEF if the query was interrupted, timed out or otherwise failed.

        def_API('Z3_fixedpoint_query_relations', INT, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, FUNC_DECL)))
 *)
function Z3_fixedpoint_query_relations(c: Z3_context; d: Z3_fixedpoint; num_relations: Cardinal; relations: PZ3_func_decl): Z3_lbool; cdecl;
  external z3_dll name  'Z3_fixedpoint_query_relations';

(**
       \brief Retrieve a formula that encodes satisfying answers to the query.


       When used in Datalog mode, the returned answer is a disjunction of conjuncts.
       Each conjunct encodes values of the bound variables of the query that are satisfied.
       In PDR mode, the returned answer is a single conjunction.

       When used in Datalog mode the previous call to #Z3_fixedpoint_query must have returned \c Z3_L_TRUE.
       When used with the PDR engine, the previous call must have been either \c Z3_L_TRUE or \c Z3_L_FALSE.

       def_API('Z3_fixedpoint_get_answer', AST, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
function Z3_fixedpoint_get_answer(c: Z3_context; d: Z3_fixedpoint): Z3_ast; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_answer';

(**
       \brief Retrieve a string that describes the last status returned by #Z3_fixedpoint_query.

       Use this method when #Z3_fixedpoint_query returns \c Z3_L_UNDEF.

       def_API('Z3_fixedpoint_get_reason_unknown', STRING, (_in(CONTEXT), _in(FIXEDPOINT) ))
 *)
function Z3_fixedpoint_get_reason_unknown(c: Z3_context; d: Z3_fixedpoint): Z3_string; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_reason_unknown';

(**
       \brief Update a named rule.
       A rule with the same name must have been previously created.

       def_API('Z3_fixedpoint_update_rule', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(AST), _in(SYMBOL)))
 *)
procedure Z3_fixedpoint_update_rule(c: Z3_context; d: Z3_fixedpoint; a: Z3_ast; name: Z3_symbol); cdecl;
  external z3_dll name  'Z3_fixedpoint_update_rule';

(**
       \brief Query the PDR engine for the maximal levels properties are known about predicate.

       This call retrieves the maximal number of relevant unfoldings
       of \c pred with respect to the current exploration state.
       Note: this functionality is PDR specific.

       def_API('Z3_fixedpoint_get_num_levels', UINT, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
 *)
function Z3_fixedpoint_get_num_levels(c: Z3_context; d: Z3_fixedpoint; pred: Z3_func_decl): Cardinal; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_num_levels';

(**
       Retrieve the current cover of \c pred up to \c level unfoldings.
       Return just the delta that is known at \c level. To
       obtain the full set of properties of \c pred one should query
       at \c level+1 , \c level+2 etc, and include \c level=-1.

       Note: this functionality is PDR specific.

       def_API('Z3_fixedpoint_get_cover_delta', AST, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL)))
 *)
function Z3_fixedpoint_get_cover_delta(c: Z3_context; d: Z3_fixedpoint; level: Integer; pred: Z3_func_decl): Z3_ast; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_cover_delta';

(**
       \brief Add property about the predicate \c pred.
       Add a property of predicate \c pred at \c level.
       It gets pushed forward when possible.

       Note: level = -1 is treated as the fixedpoint. So passing -1 for the \c level
       means that the property is true of the fixed-point unfolding with respect to \c pred.

       Note: this functionality is PDR specific.

       def_API('Z3_fixedpoint_add_cover', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(INT), _in(FUNC_DECL), _in(AST)))
 *)
procedure Z3_fixedpoint_add_cover(c: Z3_context; d: Z3_fixedpoint; level: Integer; pred: Z3_func_decl; &property: Z3_ast); cdecl;
  external z3_dll name  'Z3_fixedpoint_add_cover';

(**
       \brief Retrieve statistics information from the last call to #Z3_fixedpoint_query.

       def_API('Z3_fixedpoint_get_statistics', STATS, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
function Z3_fixedpoint_get_statistics(c: Z3_context; d: Z3_fixedpoint): Z3_stats; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_statistics';

(**
       \brief Register relation as Fixedpoint defined.
       Fixedpoint defined relations have least-fixedpoint semantics.
       For example, the relation is empty if it does not occur
       in a head or a fact.

       def_API('Z3_fixedpoint_register_relation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL)))
 *)
procedure Z3_fixedpoint_register_relation(c: Z3_context; d: Z3_fixedpoint; f: Z3_func_decl); cdecl;
  external z3_dll name  'Z3_fixedpoint_register_relation';

(**
       \brief Configure the predicate representation.

       It sets the predicate to use a set of domains given by the list of symbols.
       The domains given by the list of symbols must belong to a set
       of built-in domains.

       def_API('Z3_fixedpoint_set_predicate_representation', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(FUNC_DECL), _in(UINT), _in_array(3, SYMBOL)))
 *)
procedure Z3_fixedpoint_set_predicate_representation(c: Z3_context; d: Z3_fixedpoint; f: Z3_func_decl; num_relations: Cardinal; relation_kinds: PZ3_symbol); cdecl;
  external z3_dll name  'Z3_fixedpoint_set_predicate_representation';

(**
       \brief Retrieve set of rules from fixedpoint context.

       def_API('Z3_fixedpoint_get_rules', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
 *)
function Z3_fixedpoint_get_rules(c: Z3_context; f: Z3_fixedpoint): Z3_ast_vector; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_rules';

(**
       \brief Retrieve set of background assertions from fixedpoint context.

       def_API('Z3_fixedpoint_get_assertions', AST_VECTOR, (_in(CONTEXT),_in(FIXEDPOINT)))
 *)
function Z3_fixedpoint_get_assertions(c: Z3_context; f: Z3_fixedpoint): Z3_ast_vector; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_assertions';

(**
       \brief Set parameters on fixedpoint context.

       \sa Z3_fixedpoint_get_help
       \sa Z3_fixedpoint_get_param_descrs

       def_API('Z3_fixedpoint_set_params', VOID, (_in(CONTEXT), _in(FIXEDPOINT), _in(PARAMS)))
 *)
procedure Z3_fixedpoint_set_params(c: Z3_context; f: Z3_fixedpoint; p: Z3_params); cdecl;
  external z3_dll name  'Z3_fixedpoint_set_params';

(**
       \brief Return a string describing all fixedpoint available parameters.

       \sa Z3_fixedpoint_get_param_descrs
       \sa Z3_fixedpoint_set_params

       def_API('Z3_fixedpoint_get_help', STRING, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
function Z3_fixedpoint_get_help(c: Z3_context; f: Z3_fixedpoint): Z3_string; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_help';

(**
       \brief Return the parameter description set for the given fixedpoint object.

       \sa Z3_fixedpoint_get_help
       \sa Z3_fixedpoint_set_params

       def_API('Z3_fixedpoint_get_param_descrs', PARAM_DESCRS, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
function Z3_fixedpoint_get_param_descrs(c: Z3_context; f: Z3_fixedpoint): Z3_param_descrs; cdecl;
  external z3_dll name  'Z3_fixedpoint_get_param_descrs';

(**
       \brief Print the current rules and background axioms as a string.
       \param c - context.
       \param f - fixedpoint context.
       \param num_queries - number of additional queries to print.
       \param queries - additional queries.

       \sa Z3_fixedpoint_from_file
       \sa Z3_fixedpoint_from_string

       def_API('Z3_fixedpoint_to_string', STRING, (_in(CONTEXT), _in(FIXEDPOINT), _in(UINT), _in_array(2, AST)))
 *)
function Z3_fixedpoint_to_string(c: Z3_context; f: Z3_fixedpoint; num_queries: Cardinal; queries: PZ3_ast): Z3_string; cdecl;
  external z3_dll name  'Z3_fixedpoint_to_string';

(**
       \brief Parse an SMT-LIB2 string with fixedpoint rules.
       Add the rules to the current fixedpoint context.
       Return the set of queries in the string.

       \param c - context.
       \param f - fixedpoint context.
       \param s - string containing SMT2 specification.

       \sa Z3_fixedpoint_from_file
       \sa Z3_fixedpoint_to_string

       def_API('Z3_fixedpoint_from_string', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
 *)
function Z3_fixedpoint_from_string(c: Z3_context; f: Z3_fixedpoint; s: Z3_string): Z3_ast_vector; cdecl;
  external z3_dll name  'Z3_fixedpoint_from_string';

(**
       \brief Parse an SMT-LIB2 file with fixedpoint rules.
       Add the rules to the current fixedpoint context.
       Return the set of queries in the file.

       \param c - context.
       \param f - fixedpoint context.
       \param s - path to file containing SMT2 specification.

       \sa Z3_fixedpoint_from_string
       \sa Z3_fixedpoint_to_string

       def_API('Z3_fixedpoint_from_file', AST_VECTOR, (_in(CONTEXT), _in(FIXEDPOINT), _in(STRING)))
 *)
function Z3_fixedpoint_from_file(c: Z3_context; f: Z3_fixedpoint; s: Z3_string): Z3_ast_vector; cdecl;
  external z3_dll name  'Z3_fixedpoint_from_file';

(**
       \brief Create a backtracking point.

       The fixedpoint solver contains a set of rules, added facts and assertions.
       The set of rules, facts and assertions are restored upon calling #Z3_fixedpoint_pop.

       \sa Z3_fixedpoint_pop

       def_API('Z3_fixedpoint_push', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
procedure Z3_fixedpoint_push(c: Z3_context; d: Z3_fixedpoint); cdecl;
  external z3_dll name  'Z3_fixedpoint_push';

(**
       \brief Backtrack one backtracking point.

       \sa Z3_fixedpoint_push

       \pre The number of calls to pop cannot exceed calls to push.

       def_API('Z3_fixedpoint_pop', VOID, (_in(CONTEXT), _in(FIXEDPOINT)))
 *)
procedure Z3_fixedpoint_pop(c: Z3_context; d: Z3_fixedpoint); cdecl;
  external z3_dll name  'Z3_fixedpoint_pop';

(** \brief Initialize the context with a user-defined state. *)
procedure Z3_fixedpoint_init(c: Z3_context; d: Z3_fixedpoint; state: Pointer); cdecl;
  external z3_dll name  'Z3_fixedpoint_init';

(**
       \brief Register a callback to destructive updates.

       Registers are identified with terms encoded as fresh constants,
 *)
procedure Z3_fixedpoint_set_reduce_assign_callback(c: Z3_context; d: Z3_fixedpoint; cb: Z3_fixedpoint_reduce_assign_callback_fptr); cdecl;
  external z3_dll name  'Z3_fixedpoint_set_reduce_assign_callback';

(** \brief Register a callback for building terms based on the relational operators. *)
procedure Z3_fixedpoint_set_reduce_app_callback(c: Z3_context; d: Z3_fixedpoint; cb: Z3_fixedpoint_reduce_app_callback_fptr); cdecl;
  external z3_dll name  'Z3_fixedpoint_set_reduce_app_callback';

(** \brief set export callback for lemmas *)
procedure Z3_fixedpoint_add_callback(ctx: Z3_context; f: Z3_fixedpoint; state: Pointer; new_lemma_eh: Z3_fixedpoint_new_lemma_eh; predecessor_eh: Z3_fixedpoint_predecessor_eh; unfold_eh: Z3_fixedpoint_unfold_eh); cdecl;
  external z3_dll name  'Z3_fixedpoint_add_callback';

procedure Z3_fixedpoint_add_constraint(c: Z3_context; d: Z3_fixedpoint; e: Z3_ast; lvl: Cardinal); cdecl;
  external z3_dll name  'Z3_fixedpoint_add_constraint';

implementation

end.